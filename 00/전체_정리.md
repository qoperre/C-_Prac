너무 간략하게만 설명되어 있어서 내 맘대로 주석 좀 넣음

---

## 1. C++는 “자유로운” 언어다

C++는 **가능한 것이 많아(“자유”) 동시에 실수를 방지할 책임**도 개발자에게 요구함. 페이지에서 강조한 네 가지 메시지를 조금 확장해 보면: 

| 원문 포인트                       | 상세 설명                                                                                                    |
| ---------------------------- | -------------------------------------------------------------------------------------------------------- |
| **① C와 C++는 다르다**            | C++는 C 대부분을 포괄하지만 **형(타입)을 더 엄격히** 요구함. 즉, “C 스타일” 코드도 가능하지만 반드시 명확한 타입을 사용해 안전성을 확보해야 함.            |
| **② C++는 완전 ‘객체지향 언어’가 아니다** | OOP 기능을 제공할 뿐, **절차지향·제네릭·함수형 패러다임**도 자연스럽게 섞어 쓸 수 있음.                                                 |
| **③ C 표준 함수를 써도 된다**         | `std::printf` vs `std::cout`처럼, 상황에 따라 C 함수가 더 빠를 수 있음. 단, `std::endl`은 버퍼를 flush 하므로 남발하지 않는 편이 좋음. |
| **④ goto는 금기어가 아니다**         | `goto`도 점프 문(jump statement) 중 하나임. **가독성·유지보수성을 해치지 않는 선**에서라면 사용할 수 있으나, 복잡도를 키우지 않도록 주의해야 함.      |

> **Tip**  초보 단계에서 자유도를 통제하려면 *MISRA‑C++* 같은 코딩 가이드라인을 참고해 “표준화된 금기 목록”을 미리 정해 두면 Good.

---

## 2. Quick Reference Sheet 확장 정리

### 2‑1. 헤더 파일 추가 (`#include …`) 

```cpp
#include <vector>   // 표준 라이브러리 헤더 – 검색 경로는 컴파일러가 관리
#include "my.hpp"   // 사용자 헤더 – 현재/지정 경로를 우선 탐색
```

* `<…>` 는 **시스템·표준** 헤더, `"…"` 는 **사용자 정의** 헤더용 관례.
* 빌드 시스템(CMake 등)에서 `target_include_directories()`로 사용자 헤더 경로를 설정해 두면 `"…"`, `<…>` 모두 편히 섞어 쓸 수 있음.

### 2‑2. 주요 표준 라이브러리 헤더 

* **I/O** : `<iostream>`, `<fstream>`, `<iomanip>`
* **컨테이너·알고리즘** : `<vector>`, `<list>`, `<map>`, `<algorithm>`
* **동시성** : `<thread>`, `<mutex>`, `<future>`, `<atomic>`
* **유틸리티** : `<memory>`(스마트 포인터), `<chrono>`(시간), `<functional>`(고차 함수)

> **Tip**  필요 없는데 `<bits/stdc++.h>`처럼 “통합 헤더”를 남용하면 **컴파일 시간이 늘어남**; 실제 프로젝트에서는 목적별 최소 헤더 포함이 좋음음.

### 2‑3. 기본 자료형 ● `bool, char, int, double …` 

| 범주    | 크기 & 특징 (LP64 기준)                                   | 메모                               |
| ----- | --------------------------------------------------- | -------------------------------- |
| 부울    | `bool` (1 B)                                        | `true / false`                   |
| 정수    | `char` (1 B), `int` (4 B), `long` (8 B) 등           | `std::int32_t` 같은 **고정폭** 타입을 권장 |
| 부동소수  | `float` (4 B), `double` (8 B), `long double`        | 과학·금융 계산은 **정밀도** 확인 필수          |
| 표준 타입 | `std::string`, `std::vector<T>`, `std::array<T, N>` | RAII 덕분에 메모리 안전                  |

### 2‑4. 배열·포인터·참조자 

```cpp
int  arr[5] = {1,2,3,4,5};  // C 스타일 고정 길이
int* p      = arr;          // 포인터 – 재할당 가능
int& r      = arr[0];       // 참조 – 반드시 초기화, 불변 리바인딩
```

* 배열은 컴파일 타임 크기 고정, **`std::array`** 로 대체하면 `size()` 등 메서드 활용 가능.
* 포인터는 **널(null) 검사** 필수, 스마트 포인터(`std::unique_ptr`, `std::shared_ptr`)를 선호.
* 참조자는 *null* 상태가 없고, 인터페이스 전달 인수로 안전.

### 2‑5. 주석 `// …`, `/* … */` 

* 다중 행 주석에 다시 `/* … */`를 중첩하면 안됨.
* Doxygen 스타일 `///`, `/** … */`을 쓰면 자동 문서화에 유리.

### 2‑6. 산술·비트·관계·논리 연산자 

* **산술** : `+ - * / %` / 전위·후위 `++ --`
* **비트** : `& | ^ ~ << >>` – *부호 확장*·우선순위에 주의.
* **관계** : `< <= > >= == !=`
* **논리** : `&& || !` (단락 평가)

> **Tip**  C++20의 **`<=>` 3‑way comparison**(“spaceship”)을 사용하면 모든 비교 연산을 한 번에 생성할 수 있음음.

### 2‑7. 조건 분기문 `if/else`, `switch` 

* C++17부터 `if (init; cond)` 구문을 지원해, **초기화와 조건을 한 줄**에 쓸 수 있음.
* `switch`는 **`enum class`** 와 함께 쓰면 타입 안전 + 암시적 변환 방지.

### 2‑8. 반복문 ● `for`, `while`, `do…while`, range‑for

```cpp
for (auto& v : vec) { /* 읽기/쓰기 */ }  // range‑for
for (size_t i=0; i<vec.size(); ++i) {}    // 인덱스 기반
while (condition)   {}                    // 조건 선‑평가
do { /* … */ } while (condition);         // 후‑평가
```

* 병렬 반복은 `<execution>`+`std::for_each(std::execution::par, …)` 고려.
* 무한 루프엔 `while (true)`보다 \*\*`for (;;)`\*\*가 성능상 유리하지는 않지만, 전통적으로 쓰임.

### 2‑9. I/O 연산자 및 형식화

* 스트림 : `std::cin >> x`, `std::cout << y` – i18n에 강점.
* C‑스타일 : `scanf/printf` – 포맷이 명시적·성능 유리.
* C++20의 `std::format`(헤더 `<format>`)으로 **타입 안전 + 간결**한 문자열 포맷이 가능.

### 2‑10. 파일 I/O 기본 패턴 

```cpp
std::fstream fs("data.bin", std::ios::in | std::ios::out | std::ios::binary);
fs.read(reinterpret_cast<char*>(&obj), sizeof(obj));
fs.write(buffer, nbytes);
```

* 파일 모드 조합은 **`std::ios::in | std::ios::binary`** 같이 *비트 OR*.
* 텍스트 처리에는 `std::ifstream`, `std::ofstream` 사용이 간단.

### 2‑11. 함수 선언 & 정의 

```cpp
int add(int a, int b);          // 선언(프로토타입)
inline int add(int a,int b){    // 정의
    return a + b;
}
```

* **인라인** 함수라도 ODR(One‑Definition Rule)을 지켜야 링크 오류를 예방.
* 현대 C++에서는 **`constexpr`** 로 컴파일 타임 평가를 적극 활용.

### 2‑12. 사용자 정의 자료형 (struct/class/enum) 

* `struct`는 기본 `public`, `class`는 기본 `private`.
* `enum class Color { Red, Green };` – 스코프가 분리돼 이름 충돌 방지.
* **Rule of 0/3/5/6**: 자원 소유 여부에 따라 특별 멤버 함수(복사·이동 생성/대입·소멸자) 정의 여부를 판단.

### 2‑13. 객체 생성 패턴 

```cpp
MyClass obj;                      // 스택 객체
auto p = std::make_unique<MyClass>(); // 힙 객체 (RAII)
```

* 스마트 포인터를 사용하면 예외 발생 시 **메모리 누수** 위험이 사라짐.
* 팩토리 함수(`make_*`)를 선호하면 **버전 변경 시 타입 추론**이 쉬워짐.

---
https://wikidocs.net/25044 "00. C++ 들어가기 - C++ 이야기(A Story of C++)"
